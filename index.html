<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>AR - 모바일 디버그 개선판</title>

  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <!-- AR.js: 운영 환경에서는 버전 고정(릴리스 태그) 권장 -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #loading {
      position: absolute;
      top:0; left:0;
      width:100%; height:100%;
      background: rgba(0,0,0,0.85);
      color:#fff;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      z-index:9999;
      transition: opacity 0.25s ease;
    }
    #loading.hidden { opacity: 0; pointer-events: none; visibility: hidden; }
    #loading .box { max-width: 90%; text-align:center; padding: 16px; }
    #statusRow { margin-top: 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:center; }
    .statusBadge { background: rgba(255,255,255,0.06); padding:6px 10px; border-radius:8px; font-size:13px; color:#fff; }
    #forceHideBtn { margin-top:12px; padding:8px 12px; border:none; border-radius:6px; background:#28a745; color:#fff; cursor:pointer; }
    #forceHideBtn.secondary { background:#6c757d; }
    #debugOverlay {
      position: absolute;
      right: 8px;
      top: 8px;
      z-index: 10000;
      background: rgba(0,0,0,0.4);
      color: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="loading" role="status" aria-live="polite">
    <div class="box">
      <div id="mainMsg">시스템 초기화 중... 마커를 비춰주세요.</div>

      <div id="statusRow">
        <div id="framesStatus" class="statusBadge">프레임: 0 / 0</div>
        <div id="markerStatus" class="statusBadge">마커: 미검출</div>
        <div id="animStatus" class="statusBadge">애니: 대기</div>
      </div>

      <div style="margin-top:10px;">
        <button id="forceHideBtn">강제로 숨기기 (테스트)</button>
      </div>
    </div>
  </div>

  <div id="debugOverlay" aria-hidden="true">로그: 모바일 모드 - 콘솔 없음</div>

  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="antialias: true; alpha: true; precision: highp; logarithmicDepthBuffer: true; colorManagement: true;"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;">

    <a-nft id="nft-target" type="nft" url="" smooth="true" smoothCount="10" smoothTolerance="0.01" smoothThreshold="2">
      <a-plane
        id="animPlane"
        position="0 0 0"
        rotation="-90 0 0"
        width="1"
        height="1"
        material="shader: flat; transparent: true; side: double;"
        transparent-animator="totalFrames: 22; fps: 15; framesPath: frames/">
      </a-plane>
    </a-nft>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // 화면 요소
    const loaderDiv = document.getElementById('loading');
    const mainMsg = document.getElementById('mainMsg');
    const framesStatus = document.getElementById('framesStatus');
    const markerStatus = document.getElementById('markerStatus');
    const animStatus = document.getElementById('animStatus');
    const forceHideBtn = document.getElementById('forceHideBtn');

    function updateFramesStatus(loaded, total) {
      framesStatus.textContent = `프레임: ${loaded} / ${total}`;
    }
    function updateMarkerStatus(found) {
      markerStatus.textContent = `마커: ${found ? '감지' : '미검출'}`;
    }
    function updateAnimStatus(text) {
      animStatus.textContent = `애니: ${text}`;
    }

    function hideLoaderUI() {
      loaderDiv.classList.add('hidden');
      loaderDiv.style.pointerEvents = 'none';
    }
    function showLoaderUI(msg) {
      if (msg) mainMsg.textContent = msg;
      loaderDiv.classList.remove('hidden');
      loaderDiv.style.pointerEvents = 'auto';
    }

    // 강제 숨기기 버튼: UI만 숨기고 컴포넌트 동작을 막지 않음
    forceHideBtn.addEventListener('click', () => {
      hideLoaderUI();
      // 모바일이라 콘솔 못보는 걸 고려해 작은 안내
      document.getElementById('debugOverlay').textContent = '로더 강제 숨김. 마커를 비춰보세요.';
    });

    // transparent-animator 개선판 (더 관대하게 동작)
    AFRAME.registerComponent('transparent-animator', {
      schema: {
        totalFrames: { type: 'int', default: 22 },
        fps: { type: 'number', default: 15 },
        framesPath: { type: 'string', default: 'frames/' },
        filePrefix: { type: 'string', default: 'frame_' },
        fileExt: { type: 'string', default: '.png' }
      },

      init: function () {
        this.loader = new THREE.TextureLoader();
        if (this.loader && typeof this.loader.setCrossOrigin === 'function') {
          try { this.loader.setCrossOrigin('anonymous'); } catch (e) {}
        }

        this.textures = new Array(this.data.totalFrames);
        this.loadedCount = 0;
        this.currentIdx = 0;
        this.lastTime = performance.now();
        this.mesh = null;
        this.allLoaded = false;
        this.isVisible = false;

        // root path 계산
        const rootPath = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
        this._rootPath = rootPath;

        updateFramesStatus(this.loadedCount, this.data.totalFrames);

        // 프레임 로드: 실패가 있어도 가능한 프레임으로 재생 허용
        for (let i = 0; i < this.data.totalFrames; i++) {
          const filename = `${this.data.filePrefix}${String(i).padStart(3, '0')}${this.data.fileExt}`;
          const url = rootPath + this.data.framesPath + filename;
          this.loader.load(
            url,
            (tex) => {
              try { tex.encoding = THREE.sRGBEncoding; } catch (e) {}
              tex.minFilter = THREE.LinearFilter;
              tex.magFilter = THREE.LinearFilter;
              tex.generateMipmaps = false;
              this.textures[i] = tex;
              this.loadedCount++;
              updateFramesStatus(this.loadedCount, this.data.totalFrames);
              if (this.loadedCount === this.data.totalFrames) {
                this.allLoaded = true;
                updateAnimStatus('준비 완료');
                // 만약 마커가 이미 보이는 상태라면 곧바로 재생을 시작하게 함
              }
            },
            undefined,
            (err) => {
              this.textures[i] = null;
              this.loadedCount++;
              updateFramesStatus(this.loadedCount, this.data.totalFrames);
              if (this.loadedCount === this.data.totalFrames) {
                this.allLoaded = true;
                updateAnimStatus('준비(일부 실패 포함)');
              }
            }
          );
        }

        // 마커 이벤트 리스너: 여러 대상을 등록해서 놓칠 가능성 줄임
        const attachMarkerListeners = (target) => {
          if (!target) return;
          target.addEventListener('markerFound', () => {
            this.isVisible = true;
            updateMarkerStatus(true);
            updateAnimStatus(this.allLoaded || this.loadedCount > 0 ? '재생 중' : '로딩 중');
            // 로더 UI는 기본적으로 숨김 처리 (사용자가 강제 숨김했다면 이미 숨겨져 있음)
            hideLoaderUI();
          });
          target.addEventListener('markerLost', () => {
            this.isVisible = false;
            updateMarkerStatus(false);
            updateAnimStatus('일시정지');
            // 로더 UI를 다시 보여주고 싶지 않다면 이 라인을 주석처리하세요.
            showLoaderUI('마커를 다시 찾는 중...');
          });
        };

        // 우선 a-nft(부모), 씬(scene), document에 리스너 부착
        const parent = this.el.parentElement || this.el.parentNode;
        attachMarkerListeners(parent);
        if (this.el.sceneEl) attachMarkerListeners(this.el.sceneEl);
        attachMarkerListeners(document);

        // 안전장치: 일정 시간 뒤에도 아무 프레임도 로드되지 않으면 UI에 안내
        setTimeout(() => {
          if (this.loadedCount === 0) {
            updateAnimStatus('프레임 로드 실패 가능성');
            // 화면에 안내를 남기지만 자동으로 UI를 숨기지 않음
          }
        }, 7000);
      },

      setupMesh: function () {
        const mesh = this.el.getObject3D('mesh');
        if (!mesh) return false;
        this.mesh = mesh;
        const mat = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
        if (!mat) return false;

        mat.transparent = true;
        mat.alphaTest = 0.1;
        mat.opacity = 1.0;
        mat.side = THREE.DoubleSide;
        mat.depthWrite = false;
        mat.depthTest = true;
        mesh.renderOrder = 1;

        // 첫 사용 가능한 텍스처를 찾아 연결
        const firstTex = this.textures.find(t => !!t);
        if (firstTex) {
          mat.map = firstTex;
          if (mat.map) mat.map.needsUpdate = true;
        } else {
          mat.map = null;
        }
        mat.needsUpdate = true;
        return true;
      },

      tick: function (time/*, timeDelta */) {
        if (!this.mesh) {
          if (!this.setupMesh()) return;
        }

        // 마커가 보이지 않으면 재생 중지
        if (!this.isVisible) return;

        // 프레임이 하나도 로드되지 않았다면 아무것도 하지 않음
        if (this.loadedCount === 0) return;

        const interval = 1000 / this.data.fps;
        if (time - this.lastTime >= interval) {
          // 현재 인덱스부터 순회하여 유효한 텍스처 찾기 (null은 건너뜀)
          let attempts = 0;
          let tex = null;
          while (attempts < this.data.totalFrames) {
            const idx = (this.currentIdx + attempts) % this.data.totalFrames;
            if (this.textures[idx]) { tex = this.textures[idx]; this.currentIdx = (idx + 1) % this.data.totalFrames; break; }
            attempts++;
          }
          if (tex && this.mesh && this.mesh.material) {
            const mat = Array.isArray(this.mesh.material) ? this.mesh.material[0] : this.mesh.material;
            mat.map = tex;
            if (mat.map) mat.map.needsUpdate = true;
            updateAnimStatus('재생 중');
          } else {
            // 텍스처가 하나도 없는 경우(모두 null)에는 재생 상태 갱신
            updateAnimStatus('프레임 없음');
          }

          this.lastTime = time;
        }
      },

      remove: function () {
        try {
          if (this.textures && this.textures.length) {
            this.textures.forEach((t) => {
              if (t && typeof t.dispose === 'function') t.dispose();
            });
          }
          if (this.mesh && this.mesh.material) {
            const mat = Array.isArray(this.mesh.material) ? this.mesh.material[0] : this.mesh.material;
            if (mat) {
              if (mat.map) mat.map = null;
              if (typeof mat.dispose === 'function') mat.dispose();
            }
          }
        } catch (e) { console.warn(e); }
      }
    });

    // a-nft URL 설정 (실제 경로로 수정 필요)
    (function setupNFT() {
      const nft = document.querySelector('#nft-target');
      const rootPath = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
      const nftUrl = rootPath + 'AR/'; // AR/ 폴더(또는 descriptor 파일 경로)를 실제 환경에 맞추어 수정하세요.
      nft.setAttribute('url', nftUrl);

      // 모바일에서는 콘솔를 볼 수 없으니 오버레이 텍스트로 알려줌
      document.getElementById('debugOverlay').textContent = `NFT URL: ${nftUrl}`;
    })();
  </script>
</body>
</html>
