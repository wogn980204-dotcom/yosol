<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>AR - 사용자용 실행 페이지</title>

  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <!-- 운영 환경에서는 고정된 릴리스 버전 사용 권장 -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    html,body { height:100%; margin:0; background: #000; }
    /* 소비자용: UI 최소화. 카메라 영상과 AR만 보이게 함. */
  </style>
</head>

<body>
  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="antialias: true; alpha: true; precision: highp; colorManagement: true;"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;">

    <!-- NFT 마커: url을 실제 descriptor 경로(폴더 끝에 / 포함)로 설정하세요. -->
    <a-nft id="nft-target" type="nft" url="">
      <a-plane
        id="animPlane"
        position="0 0 0"
        rotation="-90 0 0"
        width="1"
        height="1"
        visible="false"
        /* 기본 material은 흰색이며 투명 지원하도록 명시 */
        material="color: #ffffff; side: double; transparent: true;">
      </a-plane>
    </a-nft>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // 소비자 모드 component: Canvas 기반 프레임 애니메이터 (알파 안정화)
    AFRAME.registerComponent('canvas-frame-anim', {
      schema: {
        totalFrames: { type: 'int', default: 22 },
        fps: { type: 'number', default: 15 },
        framesPath: { type: 'string', default: 'frames/' }, // index.html 기준 상대폴더
        filePrefix: { type: 'string', default: 'frame_' },
        fileExt: { type: 'string', default: '.png' },
        autoNftUrl: { type: 'string', default: 'AR/' } // 필요시 자동 설정
      },

      init: function () {
        this.images = new Array(this.data.totalFrames);
        this.loadedCount = 0;
        this.currentIdx = 0;
        this.lastTime = performance.now();
        this.playing = false;
        this.canvas = null;
        this.ctx = null;
        this.canvasTexture = null;
        this.mesh = null;

        // root path 계산 (index.html 기준)
        const root = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
        this._root = root;

        // NFT 자동 URL 설정(원치 않으면 a-nft의 url 속성 직접 설정)
        const nftEl = document.querySelector('#nft-target');
        if (nftEl && !nftEl.getAttribute('url')) {
          try { nftEl.setAttribute('url', root + this.data.autoNftUrl); } catch(e) {}
        }

        // 이미지 로드 (Image 객체 사용)
        for (let i = 0; i < this.data.totalFrames; i++) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          const filename = `${this.data.filePrefix}${String(i).padStart(3, '0')}${this.data.fileExt}`;
          img.src = root + this.data.framesPath + filename;

          img.onload = (() => {
            return (ev) => {
              this.images[i] = img;
              this.loadedCount++;
              // 캔버스 크기 설정: 첫 이미지 로드 시 캔버스 생성
              if (!this.canvas) {
                this.canvas = document.createElement('canvas');
                this.canvas.width = img.width;
                this.canvas.height = img.height;
                this.ctx = this.canvas.getContext('2d', { alpha: true });
                // 초기 클리어(투명)
                this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
                // THREE.CanvasTexture 생성
                this.canvasTexture = new THREE.CanvasTexture(this.canvas);
                this.canvasTexture.encoding = THREE.sRGBEncoding;
                this.canvasTexture.minFilter = THREE.LinearFilter;
                this.canvasTexture.magFilter = THREE.LinearFilter;
                this.canvasTexture.generateMipmaps = false;
                // 연결은 mesh 준비 후에 수행
              }
            };
          })();

          img.onerror = (() => {
            return () => {
              // 실패해도 null로 두고 전체 동작 유지
              this.images[i] = null;
              this.loadedCount++;
            };
          })();
        }

        // 마커 이벤트: a-nft 엘리먼트에 바인딩
        if (nftEl) {
          nftEl.addEventListener('markerFound', () => {
            const plane = document.querySelector('#animPlane');
            if (plane) plane.setAttribute('visible', 'true');
            this.playing = true;
            // ensure mesh re-setup
            this.mesh = null;
          });
          nftEl.addEventListener('markerLost', () => {
            const plane = document.querySelector('#animPlane');
            if (plane) plane.setAttribute('visible', 'false');
            this.playing = false;
          });
        }
      },

      setupMesh: function () {
        const planeEl = this.el;
        const mesh = planeEl.getObject3D('mesh');
        if (!mesh) return false;
        this.mesh = mesh;

        // 첫 텍스처(캔버스 텍스처)가 준비되었으면 머티리얼에 연결
        const mat = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
        if (!mat) return false;

        // 안정적 머티리얼 설정: 알파테스트와 깊이 설정
        mat.transparent = true;
        mat.alphaTest = 0.02; // 너무 높으면 자글거릴 수 있으므로 낮게 설정
        mat.side = THREE.DoubleSide;
        mat.depthWrite = false;
        mat.depthTest = true;

        if (this.canvasTexture) {
          mat.map = this.canvasTexture;
          mat.map.needsUpdate = true;
        } else {
          mat.map = null;
        }
        mat.needsUpdate = true;

        return true;
      },

      tick: function (time/*, delta */) {
        // mesh 준비
        if (!this.mesh) {
          if (!this.setupMesh()) return;
        }

        // 재생중이 아니면 skip
        if (!this.playing) return;

        // 캔버스/이미지 준비 확인 (최소 하나 이상의 이미지가 로드되어야 함)
        if (!this.canvas || this.loadedCount === 0) return;

        const interval = 1000 / this.data.fps;
        if (time - this.lastTime >= interval) {
          // find next valid image
          let attempts = 0;
          let img = null;
          while (attempts < this.data.totalFrames) {
            const idx = (this.currentIdx + attempts) % this.data.totalFrames;
            if (this.images[idx]) { img = this.images[idx]; this.currentIdx = (idx + 1) % this.data.totalFrames; break; }
            attempts++;
          }

          if (img) {
            // clear and draw image to canvas (preserve alpha)
            this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
            // drawImage fills RGBA canvas; preserves image alpha channel
            this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);
            // inform three.js texture to update from canvas
            if (this.canvasTexture) {
              this.canvasTexture.needsUpdate = true;
            }
          }

          this.lastTime = time;
        }
      },

      remove: function () {
        // dispose resources
        try {
          if (this.canvasTexture && typeof this.canvasTexture.dispose === 'function') this.canvasTexture.dispose();
        } catch (e) { /* ignore */ }
      }
    });

    // 컴포넌트를 plane에 자동 부착
    document.addEventListener('DOMContentLoaded', function () {
      const plane = document.querySelector('#animPlane');
      if (plane) plane.setAttribute('canvas-frame-anim', '');
    });
  </script>
</body>
</html>
