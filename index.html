<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>AR - 간단 실행 페이지</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <!-- AR.js (NFT 지원) - 운영 시에는 고정된 릴리스 버전 사용 권장 -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    html,body { height:100%; margin:0; }
    /* 전체 화면으로 카메라 영상과 AR이 보이도록 기본 스타일만 적용 */
  </style>
</head>

<body>
  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="antialias: true; alpha: true; precision: highp; logarithmicDepthBuffer: true; colorManagement: true;"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;">
    
    <!--
      a-nft: url은 실제 NFT descriptor(.iset/.fset 등)가 있는 폴더(또는 descriptor 파일 경로)로 변경하세요.
      예: nft.setAttribute('url', location.origin + '/AR/');
    -->
    <a-nft id="nft-target" type="nft" url="">
      <!--
        평면은 초기에는 보이지 않게 하고, 마커가 잡히면 보이도록 처리합니다.
        위치/회전/크기는 마커와의 원하는 배치에 맞게 조절하세요.
      -->
      <a-plane
        id="animPlane"
        position="0 0 0"
        rotation="-90 0 0"
        width="1"
        height="1"
        visible="false"
        material="shader: flat; transparent: true; side: double;">
      </a-plane>
    </a-nft>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    AFRAME.registerComponent('transparent-animator', {
      schema: {
        totalFrames: { type: 'int', default: 22 },
        fps: { type: 'number', default: 15 },
        framesPath: { type: 'string', default: 'frames/' }, // frames/ 폴더에 이미지가 있어야 함
        filePrefix: { type: 'string', default: 'frame_' },
        fileExt: { type: 'string', default: '.png' }
      },

      init: function () {
        this.loader = new THREE.TextureLoader();
        if (this.loader && typeof this.loader.setCrossOrigin === 'function') {
          try { this.loader.setCrossOrigin('anonymous'); } catch (e) { /* ignore */ }
        }

        this.textures = new Array(this.data.totalFrames);
        this.loadedCount = 0;
        this.currentIdx = 0;
        this.lastTime = performance.now();
        this.mesh = null;
        this.playing = false; // 마커가 잡힐 때 true로 변경

        // base path 계산 (현재 html 위치 기준)
        const root = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
        this._root = root;

        // 비동기 로드: 실패해도 가능한 프레임으로 재생
        for (let i = 0; i < this.data.totalFrames; i++) {
          const name = `${this.data.filePrefix}${String(i).padStart(3, '0')}${this.data.fileExt}`;
          const url = root + this.data.framesPath + name;
          this.loader.load(
            url,
            (tex) => {
              try { tex.encoding = THREE.sRGBEncoding; } catch (e) {}
              tex.minFilter = THREE.LinearFilter;
              tex.magFilter = THREE.LinearFilter;
              tex.generateMipmaps = false;
              this.textures[i] = tex;
              this.loadedCount++;
            },
            undefined,
            () => {
              // 실패한 프레임은 null로 두고 전체 재생에서 건너뜀
              this.textures[i] = null;
              this.loadedCount++;
            }
          );
        }

        // 마커 이벤트: a-nft (부모)에서 발생
        const nftEl = document.querySelector('#nft-target');
        const planeEl = document.querySelector('#animPlane');

        // 안전: nft url 자동 설정(필요 시 사용자가 수정)
        // 기본은 같은 경로의 'AR/' 폴더로 설정합니다. 실제 경로가 다르면 변경하세요.
        try {
          const autoUrl = this._root + 'AR/';
          if (nftEl && !nftEl.getAttribute('url')) nftEl.setAttribute('url', autoUrl);
        } catch (e) { /* ignore */ }

        if (nftEl) {
          nftEl.addEventListener('markerFound', () => {
            // 보이는 상태로 바꾸고 재생 시작
            if (planeEl) planeEl.setAttribute('visible', 'true');
            this.playing = true;
            // ensure mesh will be setup on next tick
            this.mesh = null;
          });

          nftEl.addEventListener('markerLost', () => {
            if (planeEl) planeEl.setAttribute('visible', 'false');
            this.playing = false;
          });
        }
      },

      setupMesh: function () {
        const plane = this.el;
        const mesh = plane.getObject3D('mesh');
        if (!mesh) return false;
        this.mesh = mesh;

        // 단일 머티리얼 처리
        const mat = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
        if (!mat) return false;

        // 안전한 머티리얼 설정: alphaTest로 알파가 낮은 픽셀은 discard
        mat.transparent = true;
        mat.alphaTest = 0.1;
        mat.opacity = 1.0;
        mat.side = THREE.DoubleSide;
        mat.depthWrite = false; // 투명 물체라면 depth write 끔
        mat.depthTest = true;

        // 가능한 첫 텍스처를 연결 (없으면 null)
        const first = this.textures.find(t => !!t);
        if (first) {
          mat.map = first;
          if (mat.map) mat.map.needsUpdate = true;
        } else {
          mat.map = null;
        }
        mat.needsUpdate = true;

        return true;
      },

      tick: function (time/*, timeDelta */) {
        // mesh 준비
        if (!this.mesh) {
          if (!this.setupMesh()) return;
        }

        // 재생 상태가 아니면 아무것도 하지 않음
        if (!this.playing) return;

        // 적어도 하나의 텍스처가 로드되어 있어야 재생
        const any = this.textures.some(t => !!t);
        if (!any) return;

        const interval = 1000 / this.data.fps;
        if (time - this.lastTime >= interval) {
          // 현재 인덱스부터 순회하여 유효한 텍스처 찾기
          let attempts = 0;
          let tex = null;
          while (attempts < this.data.totalFrames) {
            const idx = (this.currentIdx + attempts) % this.data.totalFrames;
            if (this.textures[idx]) { tex = this.textures[idx]; this.currentIdx = (idx + 1) % this.data.totalFrames; break; }
            attempts++;
          }

          if (tex && this.mesh && this.mesh.material) {
            const mat = Array.isArray(this.mesh.material) ? this.mesh.material[0] : this.mesh.material;
            // map 교체 (가능하면 material.needsUpdate는 최소화)
            mat.map = tex;
            if (mat.map) mat.map.needsUpdate = true;
          }

          this.lastTime = time;
        }
      },

      remove: function () {
        // 리소스 정리(안정성)
        try {
          if (this.textures && this.textures.length) {
            this.textures.forEach(t => { if (t && typeof t.dispose === 'function') t.dispose(); });
          }
        } catch (e) { /* ignore */ }
      }
    });

    // 컴포넌트 연결: 평면에 자동으로 추가
    document.addEventListener('DOMContentLoaded', function () {
      const plane = document.querySelector('#animPlane');
      if (plane) plane.setAttribute('transparent-animator', '');
    });
  </script>
</body>
</html>
