<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>AR Debug - 로딩/마커 진단</title>

  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <!-- AR.js: 운영 환경에서는 버전 고정(릴리스 태그) 권장 -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #loading {
      position: absolute;
      top:0; left:0;
      width:100%; height:100%;
      background: rgba(0,0,0,0.85);
      color:#fff;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      z-index:9999;
      transition: opacity 0.25s ease;
    }
    #loading.hidden { opacity: 0; pointer-events: none; visibility: hidden; }
    #loading .box { max-width: 90%; text-align:center; padding: 16px; }
    #statusLog { margin-top: 12px; font-size: 13px; color:#ddd; text-align:left; max-height:180px; overflow:auto; width:320px; background: rgba(255,255,255,0.04); padding:8px; border-radius:6px; }
    #forceHideBtn { margin-top:12px; padding:8px 12px; border:none; border-radius:6px; background:#28a745; color:#fff; cursor:pointer; }
    #forceHideBtn.secondary { background:#6c757d; }
  </style>
</head>

<body>
  <div id="loading" role="status" aria-live="polite">
    <div class="box">
      <div id="mainMsg">시스템 초기화 중... 마커를 비춰주세요.</div>
      <div id="statusLog"></div>
      <div style="margin-top:10px;">
        <button id="forceHideBtn">강제로 숨기기 (테스트)</button>
        <button id="toggleDebugBtn" class="secondary" style="margin-left:8px;">디버그 콘솔 표시</button>
      </div>
    </div>
  </div>

  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="antialias: true; alpha: true; precision: highp; logarithmicDepthBuffer: true; colorManagement: true;"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;">

    <a-nft id="nft-target" type="nft" url="" smooth="true" smoothCount="10" smoothTolerance="0.01" smoothThreshold="2">
      <a-plane
        id="animPlane"
        position="0 0 0"
        rotation="-90 0 0"
        width="1"
        height="1"
        material="shader: flat; transparent: true; side: double;"
        transparent-animator="totalFrames: 22; fps: 15; framesPath: frames/">
      </a-plane>
    </a-nft>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // 유틸: 로깅 UI
    const loaderDiv = document.getElementById('loading');
    const mainMsg = document.getElementById('mainMsg');
    const statusLog = document.getElementById('statusLog');
    function uiLog(msg) {
      console.log('[UI]', msg);
      const el = document.createElement('div');
      el.textContent = (new Date()).toLocaleTimeString() + ' - ' + msg;
      statusLog.appendChild(el);
      statusLog.scrollTop = statusLog.scrollHeight;
    }
    document.getElementById('forceHideBtn').addEventListener('click', () => {
      uiLog('사용자 강제 숨김 버튼 클릭');
      hideLoader();
    });
    document.getElementById('toggleDebugBtn').addEventListener('click', () => {
      // 브라우저 콘솔이 열려있어야 로그 확인 가능; 추가 동작은 없음
      uiLog('콘솔을 확인하세요(개발자 도구).');
    });

    function showLoader(msg) {
      if (msg) mainMsg.textContent = msg;
      loaderDiv.classList.remove('hidden');
      loaderDiv.style.pointerEvents = 'auto';
    }
    function hideLoader(msg) {
      if (msg) uiLog(msg);
      loaderDiv.classList.add('hidden');
      // pointer-events none으로 씬 상호작용 방해 제거
      loaderDiv.style.pointerEvents = 'none';
    }

    // transparent-animator 컴포넌트 (개선판, 디버그 로그 포함)
    AFRAME.registerComponent('transparent-animator', {
      schema: {
        totalFrames: { type: 'int', default: 22 },
        fps: { type: 'number', default: 15 },
        framesPath: { type: 'string', default: 'frames/' },
        filePrefix: { type: 'string', default: 'frame_' },
        fileExt: { type: 'string', default: '.png' }
      },

      init: function () {
        uiLog('transparent-animator init');
        this.loader = new THREE.TextureLoader();
        if (this.loader && typeof this.loader.setCrossOrigin === 'function') {
          try { this.loader.setCrossOrigin('anonymous'); } catch (e) { console.warn(e); }
        }
        this.textures = new Array(this.data.totalFrames);
        this.loadedCount = 0;
        this.currentIdx = 0;
        this.lastTime = performance.now();
        this.mesh = null;
        this.allLoaded = false;
        this.isVisible = false;

        // root path 계산
        const rootPath = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
        this._rootPath = rootPath;
        uiLog('프레임 루트: ' + rootPath + this.data.framesPath);

        for (let i = 0; i < this.data.totalFrames; i++) {
          const filename = `${this.data.filePrefix}${String(i).padStart(3, '0')}${this.data.fileExt}`;
          const url = rootPath + this.data.framesPath + filename;
          this.loader.load(
            url,
            (tex) => {
              try { tex.encoding = THREE.sRGBEncoding; } catch (e) {}
              tex.minFilter = THREE.LinearFilter;
              tex.magFilter = THREE.LinearFilter;
              tex.generateMipmaps = false;
              this.textures[i] = tex;
              this.loadedCount++;
              uiLog(`프레임 ${i} 로드 완료 (${this.loadedCount}/${this.data.totalFrames})`);
              if (this.loadedCount === this.data.totalFrames) {
                this.allLoaded = true;
                uiLog('모든 프레임 로드 완료');
              }
            },
            undefined,
            (err) => {
              this.textures[i] = null;
              this.loadedCount++;
              uiLog(`프레임 ${i} 로드 실패: ${url}`);
              if (this.loadedCount === this.data.totalFrames) {
                this.allLoaded = true;
                uiLog('프레임 로드 완료(일부 실패 포함)');
              }
            }
          );
        }

        // 부모(마커) 이벤트 바인딩: 찾기/놓침 이벤트
        // 부모가 a-nft일 것으로 기대
        const parent = this.el.parentElement || this.el.parentNode;
        if (parent) {
          parent.addEventListener('markerFound', () => {
            uiLog('parent markerFound 이벤트 수신');
            this.isVisible = true;
          });
          parent.addEventListener('markerLost', () => {
            uiLog('parent markerLost 이벤트 수신');
            this.isVisible = false;
          });
        } else {
          uiLog('parent element 없음 - 마커 이벤트를 못받을 수 있음');
        }
      },

      setupMesh: function () {
        const mesh = this.el.getObject3D('mesh');
        if (!mesh) return false;
        this.mesh = mesh;
        const mat = Array.isArray(mesh.material) ? mesh.material[0] : mesh.material;
        if (!mat) return false;

        mat.transparent = true;
        mat.alphaTest = 0.1;
        mat.opacity = 1.0;
        mat.side = THREE.DoubleSide;
        mat.depthWrite = false;
        mat.depthTest = true;
        mesh.renderOrder = 1;

        if (this.textures[0]) {
          mat.map = this.textures[0];
          if (mat.map) mat.map.needsUpdate = true;
        }
        mat.needsUpdate = true;
        uiLog('메쉬/머티리얼 설정 완료');
        return true;
      },

      tick: function (time/*, timeDelta */) {
        if (!this.mesh) {
          if (!this.setupMesh()) return;
        }
        if (!this.isVisible) return;
        if (!this.allLoaded) return;

        const interval = 1000 / this.data.fps;
        if (time - this.lastTime >= interval) {
          const tex = this.textures[this.currentIdx];
          if (tex && this.mesh && this.mesh.material) {
            const mat = Array.isArray(this.mesh.material) ? this.mesh.material[0] : this.mesh.material;
            mat.map = tex;
            if (mat.map) mat.map.needsUpdate = true;
          }
          this.currentIdx = (this.currentIdx + 1) % this.data.totalFrames;
          this.lastTime = time;
        }
      },

      remove: function () {
        uiLog('transparent-animator remove 호출 - 리소스 해제 시도');
        try {
          if (this.textures && this.textures.length) {
            this.textures.forEach((t) => {
              if (t && typeof t.dispose === 'function') t.dispose();
            });
          }
          if (this.mesh && this.mesh.material) {
            const mat = Array.isArray(this.mesh.material) ? this.mesh.material[0] : this.mesh.material;
            if (mat && typeof mat.dispose === 'function') mat.dispose();
          }
        } catch (e) {
          console.warn(e);
        }
      }
    });

    // a-nft URL 설정 및 전반적 디버깅
    (function setup() {
      const nft = document.querySelector('#nft-target');
      const rootPath = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
      const nftUrl = rootPath + 'AR/'; // 실제 NFT descriptor 폴더(또는 descriptor 파일 경로)로 수정 필요
      uiLog('설정된 NFT URL: ' + nftUrl);
      console.log('설정된 NFT URL:', nftUrl);
      nft.setAttribute('url', nftUrl);

      // a-nft 및 씬 이벤트 확인
      nft.addEventListener('markerFound', () => {
        uiLog('a-nft markerFound 이벤트 발생');
        // 모든 프레임이 준비되어 있으면 로더 숨김
        setTimeout(() => {
          // 컴포넌트 내 상태가 바뀔 수 있으므로 약간 지연
          const comp = document.querySelector('#animPlane').components['transparent-animator'];
          if (comp && comp.allLoaded) {
            hideLoader('마커 발견 및 프레임 준비 완료 - 로더 숨김');
          } else {
            uiLog('마커 발견 - 하지만 프레임 로드가 아직 완료되지 않았을 수 있음');
          }
        }, 200);
      });

      nft.addEventListener('markerLost', () => {
        uiLog('a-nft markerLost 이벤트 발생');
        // 마커가 사라지면 로더 재표시(선택)
        showLoader('마커를 다시 찾을 때까지 대기 중...');
      });

      // 안전장치: 만약 10초 안에 마커 못찾으면 로더 자동 숨김(사용자 테스트용)
      setTimeout(() => {
        uiLog('타임아웃 검사: 10초 경과');
        if (!document.querySelector('#animPlane').components['transparent-animator'].isVisible) {
          uiLog('마커를 찾지 못함 — 강제 숨김 제안');
          // 주석처리하려면 아래 호출 제거
          // hideLoader('마커를 찾지 못해 로더를 자동으로 숨깁니다(테스트 목적).');
        }
      }, 10000);
    })();
  </script>
</body>
</html>
